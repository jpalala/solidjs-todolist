'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const testElem = document.createElement("div");

function cloneProps(props) {
  const propKeys = Object.keys(props);
  return propKeys.reduce((memo, k) => {
    const prop = props[k];
    memo[k] = Object.assign({}, prop);
    if (isObject(prop.value) && !isFunction(prop.value) && !Array.isArray(prop.value)) memo[k].value = Object.assign({}, prop.value);
    if (Array.isArray(prop.value)) memo[k].value = prop.value.slice(0);
    return memo;
  }, {});
}

const nativeShadowDOM = !!testElem.attachShadow;
function normalizePropDefs(props) {
  if (!props) return {};
  const propKeys = Object.keys(props);
  return propKeys.reduce((memo, k) => {
    const v = props[k];
    memo[k] = !(isObject(v) && "value" in v) ? {
      value: v
    } : v;
    memo[k].notify != null || (memo[k].notify = false);
    memo[k].attribute || (memo[k].attribute = toAttribute(k));
    return memo;
  }, {});
}
function propValues(props) {
  const propKeys = Object.keys(props);
  return propKeys.reduce((memo, k) => {
    memo[k] = props[k].value;
    return memo;
  }, {});
}
function initializeProps(element, propDefinition) {
  const props = cloneProps(propDefinition),
        propKeys = Object.keys(propDefinition);
  propKeys.forEach(key => {
    const prop = props[key],
          attr = element.getAttribute(prop.attribute),
          value = element[key];
    if (attr) prop.value = parseAttributeValue(attr);
    if (value != null) prop.value = Array.isArray(value) ? value.slice(0) : value;
    reflect(element, prop.attribute, prop.value);
    Object.defineProperty(element, key, {
      get() {
        return prop.value;
      },

      set(val) {
        const oldValue = prop.value;
        prop.value = val;
        reflect(this, prop.attribute, prop.value);

        for (let i = 0, l = this.__propertyChangedCallbacks.length; i < l; i++) {
          this.__propertyChangedCallbacks[i](key, val, oldValue);
        }
      },

      enumerable: true,
      configurable: true
    });
  });
  return props;
}
function parseAttributeValue(value) {
  if (!value) return;
  let parsed;

  try {
    parsed = JSON.parse(value);
  } catch (err) {
    parsed = value;
  }

  if (!(typeof parsed === "string")) return parsed;
  if (/^[0-9]*$/.test(parsed)) return +parsed;
  return parsed;
}
function reflect(node, attribute, value) {
  if (isObject(value)) return;
  let reflect = value ? typeof value.toString === "function" ? value.toString() : undefined : undefined;

  if (reflect && reflect !== "false") {
    node.__updating[attribute] = true;
    if (reflect === "true") reflect = "";
    node.setAttribute(attribute, reflect);
    Promise.resolve().then(() => delete node.__updating[attribute]);
  } else node.removeAttribute(attribute);
}
function toAttribute(propName) {
  return propName.replace(/\.?([A-Z]+)/g, (x, y) => "-" + y.toLowerCase()).replace("_", "-").replace(/^-/, "");
}
function toProperty(attr) {
  return attr.toLowerCase().replace(/(-)([a-z])/g, test => test.toUpperCase().replace("-", ""));
}
function toComponentName(tag) {
  return tag.toLowerCase().replace(/(^|-)([a-z])/g, test => test.toUpperCase().replace("-", ""));
}
function isObject(obj) {
  return obj != null && (typeof obj === "object" || typeof obj === "function");
}
function isFunction(val) {
  return Object.prototype.toString.call(val) === "[object Function]";
}
function isConstructor(f) {
  return typeof f === "function" && f.toString().indexOf("class") === 0;
}
function connectedToDOM(node) {
  if ("isConnected" in node) return node.isConnected;
  const doc = node.ownerDocument;
  if (!doc) return false;
  if (doc.body.contains(node)) return true;

  while (node && node !== doc.documentElement) {
    node = node.parentNode || node.host;
  }

  return node === doc.documentElement;
}

let currentElement;
function getCurrentElement() {
  return currentElement;
}
function noShadowDOM() {
  Object.defineProperty(currentElement, "renderRoot", {
    value: currentElement
  });
}
function createElementType(BaseElement, propDefinition) {
  const propKeys = Object.keys(propDefinition);
  return class CustomElement extends BaseElement {
    static get observedAttributes() {
      return propKeys.map(k => propDefinition[k].attribute);
    }

    constructor() {
      super();
      this.__initializing = false;
      this.__initialized = false;
      this.__released = false;
      this.__releaseCallbacks = [];
      this.__propertyChangedCallbacks = [];
      this.__updating = {};
      this.props = {};
    }

    connectedCallback() {
      // check that infact it connected since polyfill sometimes double calls
      if (!connectedToDOM(this) || this.__initializing || this.__initialized) return;
      this.__releaseCallbacks = [];
      this.__propertyChangedCallbacks = [];
      this.__updating = {};
      this.props = initializeProps(this, propDefinition);
      const props = propValues(this.props),
            ComponentType = this.Component,
            outerElement = currentElement;

      try {
        this.__initializing = true;
        currentElement = this;
        if (isConstructor(ComponentType)) new ComponentType(props, {
          element: this
        });else ComponentType(props, {
          element: this
        });
      } catch (err) {
        console.error(`Error creating component ${toComponentName(this.nodeName.toLowerCase())}:`, err);
      } finally {
        currentElement = outerElement;
        delete this.__initializing;
      }

      this.__initialized = true;
    }

    async disconnectedCallback() {
      // prevent premature releasing when element is only temporarely removed from DOM
      await Promise.resolve();
      if (connectedToDOM(this)) return;
      this.__propertyChangedCallbacks.length = 0;
      let callback = null;

      while (callback = this.__releaseCallbacks.pop()) callback(this);

      delete this.__initialized;
      this.__released = true;
    }

    attributeChangedCallback(name, oldVal, newVal) {
      if (!this.__initialized) return;
      if (this.__updating[name]) return;
      name = this.lookupProp(name);

      if (name in propDefinition) {
        if (newVal == null && !this[name]) return;
        this[name] = parseAttributeValue(newVal);
      }
    }

    reloadComponent() {
      let callback = null;

      while (callback = this.__releaseCallbacks.pop()) callback(this);

      delete this.__initialized;
      this.renderRoot.textContent = "";
      this.connectedCallback();
    }

    lookupProp(attrName) {
      if (!propDefinition) return;
      return propKeys.find(k => attrName === k || attrName === propDefinition[k].attribute);
    }

    get renderRoot() {
      return this.shadowRoot || this.attachShadow({
        mode: "open"
      });
    }

    setProperty(name, value) {
      if (!(name in this.props)) return;
      const prop = this.props[name],
            oldValue = prop.value;
      this[name] = value;
      if (prop.notify) this.trigger("propertychange", {
        detail: {
          value,
          oldValue,
          name
        }
      });
    }

    trigger(name, {
      detail,
      bubbles = true,
      cancelable = true,
      composed = true
    } = {}) {
      const event = new CustomEvent(name, {
        detail,
        bubbles,
        cancelable,
        composed
      });
      let cancelled = false;
      if (this["on" + name]) cancelled = this["on" + name](event) === false;
      if (cancelled) event.preventDefault();
      this.dispatchEvent(event);
      return event;
    }

    addReleaseCallback(fn) {
      this.__releaseCallbacks.push(fn);
    }

    addPropertyChangedCallback(fn) {
      this.__propertyChangedCallbacks.push(fn);
    }

  };
}

function createMixin(mixinFn) {
  return ComponentType => (props, options) => {
    options = mixinFn(options);
    if (isConstructor(ComponentType)) return new ComponentType(props, options);
    return ComponentType(props, options);
  };
}
function compose(...fns) {
  if (fns.length === 0) return i => i;
  if (fns.length === 1) return fns[0];
  return fns.reduce((a, b) => (...args) => a(b(...args)));
}

const EC = Symbol('element-context');

function lookupContext(element, context) {
  return element[EC] && element[EC][context.id] || (element.host || element.parentNode) && lookupContext(element.host || element.parentNode, context);
}

function createContext(initFn) {
  return {
    id: Symbol('context'),
    initFn
  };
} // Direct

function provide(context, value, element = getCurrentElement()) {
  element[EC] || (element[EC] = {});
  return element[EC][context.id] = context.initFn ? context.initFn(value) : value;
}
function consume(context, element = getCurrentElement()) {
  return lookupContext(element, context);
} // HOCs

function withProvider(context, value) {
  return createMixin(options => {
    const {
      element
    } = options;
    provide(context, value, element);
    return options;
  });
}
function withConsumer(context, key) {
  return createMixin(options => {
    const {
      element
    } = options;
    options = Object.assign({}, options, {
      [key]: lookupContext(element, context)
    });
    return options;
  });
}

function walk(root, call) {
  call(root);
  if (root.shadowRoot) walk(root.shadowRoot, call);
  let child = root.firstChild;

  while (child) {
    child.nodeType === 1 && walk(child, call);
    child = child.nextSibling;
  }
}

function hot(module, tagName) {
  if (module.hot) {
    function update(possibleError) {
      if (possibleError && possibleError instanceof Error) {
        console.error(possibleError);
        return;
      }

      walk(document.body, node => node.localName === tagName && setTimeout(() => node.reloadComponent(), 0));
    } // handle both Parcel and Webpack style


    module.hot.accept(update);

    if (module.hot.status && module.hot.status() === 'apply') {
      update();
    }
  }
}

function register(tag, props = {}, options = {}) {
  const {
    BaseElement = HTMLElement,
    extension
  } = options;
  return ComponentType => {
    if (!tag) throw new Error("tag is required to register a Component");
    let ElementType = customElements.get(tag);

    if (ElementType) {
      // Consider disabling this in a production mode
      ElementType.prototype.Component = ComponentType;
      return ElementType;
    }

    ElementType = createElementType(BaseElement, normalizePropDefs(props));
    ElementType.prototype.Component = ComponentType;
    ElementType.prototype.registeredTag = tag;
    customElements.define(tag, ElementType, extension);
    return ElementType;
  };
}

exports.compose = compose;
exports.connectedToDOM = connectedToDOM;
exports.consume = consume;
exports.createContext = createContext;
exports.createMixin = createMixin;
exports.getCurrentElement = getCurrentElement;
exports.hot = hot;
exports.isConstructor = isConstructor;
exports.isFunction = isFunction;
exports.isObject = isObject;
exports.nativeShadowDOM = nativeShadowDOM;
exports.noShadowDOM = noShadowDOM;
exports.provide = provide;
exports.register = register;
exports.toAttribute = toAttribute;
exports.toComponentName = toComponentName;
exports.toProperty = toProperty;
exports.withConsumer = withConsumer;
exports.withProvider = withProvider;
